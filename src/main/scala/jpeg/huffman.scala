package jpeg

import chisel3._
import chisel3.util._

class HuffmanDcEncoder extends Module {
  val io = IO(new Bundle {
    val in = Flipped(Valid(new Bundle {
      val value = SInt(12.W)
      val isLuminance = Bool()
    }))
    val out = Valid(new Bundle {
      val bits = UInt(16.W)
      val length = UInt(8.W)
    })
  })

  // 計算絕對值
  val absValue = Mux(io.in.bits.value < 0.S, -io.in.bits.value, io.in.bits.value).asUInt

  // 計算 category
  val category = Wire(UInt(4.W))
  when(absValue === 0.U) {
    category := 0.U
  }.elsewhen(absValue <= 1.U) {
    category := 1.U
  }.elsewhen(absValue <= 3.U) {
    category := 2.U
  }.elsewhen(absValue <= 7.U) {
    category := 3.U
  }.elsewhen(absValue <= 15.U) {
    category := 4.U
  }.elsewhen(absValue <= 31.U) {
    category := 5.U
  }.elsewhen(absValue <= 63.U) {
    category := 6.U
  }.elsewhen(absValue <= 127.U) {
    category := 7.U
  }.elsewhen(absValue <= 255.U) {
    category := 8.U
  }.elsewhen(absValue <= 511.U) {
    category := 9.U
  }.elsewhen(absValue <= 1023.U) {
    category := 10.U
  }.otherwise {
    category := 11.U
  }

  // DC 亮度的 Huffman 表
  val luminanceDcTable = VecInit(Seq(
    "b00".U(16.W),         // 0: 00
    "b010".U(16.W),        // 1: 010
    "b011".U(16.W),        // 2: 011
    "b100".U(16.W),        // 3: 100
    "b101".U(16.W),        // 4: 101
    "b110".U(16.W),        // 5: 110
    "b1110".U(16.W),       // 6: 1110
    "b11110".U(16.W),      // 7: 11110
    "b111110".U(16.W),     // 8: 111110
    "b1111110".U(16.W),    // 9: 1111110
    "b11111110".U(16.W),   // 10: 11111110
    "b111111110".U(16.W)   // 11: 111111110
  ))

  // DC 色度的 Huffman 表
  val chrominanceDcTable = VecInit(Seq(
    "b00".U(16.W),         // 0: 00
    "b01".U(16.W),         // 1: 01
    "b10".U(16.W),         // 2: 10
    "b110".U(16.W),        // 3: 110
    "b1110".U(16.W),       // 4: 1110
    "b11110".U(16.W),      // 5: 11110
    "b111110".U(16.W),     // 6: 111110
    "b1111110".U(16.W),    // 7: 1111110
    "b11111110".U(16.W),   // 8: 11111110
    "b111111110".U(16.W),  // 9: 111111110
    "b1111111110".U(16.W), // 10: 1111111110
    "b11111111110".U(16.W) // 11: 11111111110
  ))

  // 選擇表並獲取編碼
  val selectedTable = Mux(io.in.bits.isLuminance, luminanceDcTable, chrominanceDcTable)
  val huffmanCode = selectedTable(category)

  // 編碼長度表
  val lengthTable = VecInit(Seq(
    2.U,  // category 0
    3.U,  // category 1
    3.U,  // category 2
    3.U,  // category 3
    3.U,  // category 4
    3.U,  // category 5
    4.U,  // category 6
    5.U,  // category 7
    6.U,  // category 8
    7.U,  // category 9
    8.U,  // category 10
    9.U   // category 11
  ))

  // 輸出
  io.out.bits.bits := huffmanCode
  io.out.bits.length := lengthTable(category)
  io.out.valid := io.in.valid
}

class HuffmanEntry extends Bundle {
    val runSize = UInt(8.W)
    val code = UInt(16.W)
    val length = UInt(5.W)
  }
object luminanceAcTable {
  def apply():Vec[HuffmanEntry] = {
    VecInit(Seq(
    (0x00.U, "b1010".U, 4.U),           // 0/0
    (0x01.U, "b00".U, 2.U),           // 0/1
    (0x02.U, "b01".U, 2.U),           // 0/2
    (0x03.U, "b100".U, 3.U),           // 0/3
    (0x04.U, "b1011".U, 4.U),           // 0/4
    (0x05.U, "b11010".U, 5.U),           // 0/5
    (0x06.U, "b1111000".U, 7.U),           // 0/6
    (0x07.U, "b11111000".U, 8.U),           // 0/7
    (0x08.U, "b1111110110".U, 10.U),           // 0/8
    (0x09.U, "b1111111110000010".U, 16.U),           // 0/9
    (0x0A.U, "b1111111110000011".U, 16.U),           // 0/10
    (0x11.U, "b1100".U, 4.U),           // 0/1
    (0x12.U, "b11011".U, 5.U),           // 0/2
    (0x13.U, "b1111001".U, 7.U),           // 0/3
    (0x14.U, "b111110110".U, 9.U),           // 0/4
    (0x15.U, "b11111110110".U, 11.U),           // 0/5
    (0x16.U, "b1111111110000100".U, 16.U),           // 0/6
    (0x17.U, "b1111111110000101".U, 16.U),           // 0/7
    (0x18.U, "b1111111110000110".U, 16.U),           // 0/8
    (0x19.U, "b1111111110000111".U, 16.U),           // 0/9
    (0x1A.U, "b1111111110001000".U, 16.U),           // 0/10
    (0x21.U, "b11100".U, 5.U),           // 0/1
    (0x22.U, "b11111001".U, 8.U),           // 0/2
    (0x23.U, "b1111110111".U, 10.U),           // 0/3
    (0x24.U, "b111111110100".U, 12.U),           // 0/4
    (0x25.U, "b1111111110001001".U, 16.U),           // 0/5
    (0x26.U, "b1111111110001010".U, 16.U),           // 0/6
    (0x27.U, "b1111111110001011".U, 16.U),           // 0/7
    (0x28.U, "b1111111110001100".U, 16.U),           // 0/8
    (0x29.U, "b1111111110001101".U, 16.U),           // 0/9
    (0x2A.U, "b1111111110001110".U, 16.U),           // 0/10
    (0x31.U, "b111010".U, 6.U),           // 0/1
    (0x32.U, "b111110111".U, 9.U),           // 0/2
    (0x33.U, "b111111110101".U, 12.U),           // 0/3
    (0x34.U, "b1111111110001111".U, 16.U),           // 0/4
    (0x35.U, "b1111111110010000".U, 16.U),           // 0/5
    (0x36.U, "b1111111110010001".U, 16.U),           // 0/6
    (0x37.U, "b1111111110010010".U, 16.U),           // 0/7
    (0x38.U, "b1111111110010011".U, 16.U),           // 0/8
    (0x39.U, "b1111111110010100".U, 16.U),           // 0/9
    (0x3A.U, "b1111111110010101".U, 16.U),           // 0/10
    (0x41.U, "b111011".U, 6.U),           // 0/1
    (0x42.U, "b1111111000".U, 10.U),           // 0/2
    (0x43.U, "b1111111110010110".U, 16.U),           // 0/3
    (0x44.U, "b1111111110010111".U, 16.U),           // 0/4
    (0x45.U, "b1111111110011000".U, 16.U),           // 0/5
    (0x46.U, "b1111111110011001".U, 16.U),           // 0/6
    (0x47.U, "b1111111110011010".U, 16.U),           // 0/7
    (0x48.U, "b1111111110011011".U, 16.U),           // 0/8
    (0x49.U, "b1111111110011100".U, 16.U),           // 0/9
    (0x4A.U, "b1111111110011101".U, 16.U),           // 0/10
    (0x51.U, "b1111010".U, 7.U),           // 0/1
    (0x52.U, "b11111110111".U, 11.U),           // 0/2
    (0x53.U, "b1111111110011110".U, 16.U),           // 0/3
    (0x54.U, "b1111111110011111".U, 16.U),           // 0/4
    (0x55.U, "b1111111110100000".U, 16.U),           // 0/5
    (0x56.U, "b1111111110100001".U, 16.U),           // 0/6
    (0x57.U, "b1111111110100010".U, 16.U),           // 0/7
    (0x58.U, "b1111111110100011".U, 16.U),           // 0/8
    (0x59.U, "b1111111110100100".U, 16.U),           // 0/9
    (0x5A.U, "b1111111110100101".U, 16.U),           // 0/10
    (0x61.U, "b1111011".U, 7.U),           // 0/1
    (0x62.U, "b111111110110".U, 12.U),           // 0/2
    (0x63.U, "b1111111110100110".U, 16.U),           // 0/3
    (0x64.U, "b1111111110100111".U, 16.U),           // 0/4
    (0x65.U, "b1111111110101000".U, 16.U),           // 0/5
    (0x66.U, "b1111111110101001".U, 16.U),           // 0/6
    (0x67.U, "b1111111110101010".U, 16.U),           // 0/7
    (0x68.U, "b1111111110101011".U, 16.U),           // 0/8
    (0x69.U, "b1111111110101100".U, 16.U),           // 0/9
    (0x6A.U, "b1111111110101101".U, 16.U),           // 0/10
    (0x71.U, "b11111010".U, 8.U),           // 0/1
    (0x72.U, "b111111110111".U, 12.U),           // 0/2
    (0x73.U, "b1111111110101110".U, 16.U),           // 0/3
    (0x74.U, "b1111111110101111".U, 16.U),           // 0/4
    (0x75.U, "b1111111110110000".U, 16.U),           // 0/5
    (0x76.U, "b1111111110110001".U, 16.U),           // 0/6
    (0x77.U, "b1111111110110010".U, 16.U),           // 0/7
    (0x78.U, "b1111111110110011".U, 16.U),           // 0/8
    (0x79.U, "b1111111110110100".U, 16.U),           // 0/9
    (0x7A.U, "b1111111110110101".U, 16.U),           // 0/10
    (0x81.U, "b111111000".U, 9.U),           // 0/1
    (0x82.U, "b111111111000000".U, 15.U),           // 0/2
    (0x83.U, "b1111111110110110".U, 16.U),           // 0/3
    (0x84.U, "b1111111110110111".U, 16.U),           // 0/4
    (0x85.U, "b1111111110111000".U, 16.U),           // 0/5
    (0x86.U, "b1111111110111001".U, 16.U),           // 0/6
    (0x87.U, "b1111111110111010".U, 16.U),           // 0/7
    (0x88.U, "b1111111110111011".U, 16.U),           // 0/8
    (0x89.U, "b1111111110111100".U, 16.U),           // 0/9
    (0x8A.U, "b1111111110111101".U, 16.U),           // 0/10
    (0x91.U, "b111111001".U, 9.U),           // 0/1
    (0x92.U, "b1111111110111110".U, 16.U),           // 0/2
    (0x93.U, "b1111111110111111".U, 16.U),           // 0/3
    (0x94.U, "b1111111111000000".U, 16.U),           // 0/4
    (0x95.U, "b1111111111000001".U, 16.U),           // 0/5
    (0x96.U, "b1111111111000010".U, 16.U),           // 0/6
    (0x97.U, "b1111111111000011".U, 16.U),           // 0/7
    (0x98.U, "b1111111111000100".U, 16.U),           // 0/8
    (0x99.U, "b1111111111000101".U, 16.U),           // 0/9
    (0x9A.U, "b1111111111000110".U, 16.U),           // 0/10
    (0xA1.U, "b111111010".U, 9.U),           // 0/1
    (0xA2.U, "b1111111111000111".U, 16.U),           // 0/2
    (0xA3.U, "b1111111111001000".U, 16.U),           // 0/3
    (0xA4.U, "b1111111111001001".U, 16.U),           // 0/4
    (0xA5.U, "b1111111111001010".U, 16.U),           // 0/5
    (0xA6.U, "b1111111111001011".U, 16.U),           // 0/6
    (0xA7.U, "b1111111111001100".U, 16.U),           // 0/7
    (0xA8.U, "b1111111111001101".U, 16.U),           // 0/8
    (0xA9.U, "b1111111111001110".U, 16.U),           // 0/9
    (0xAA.U, "b1111111111001111".U, 16.U),           // 0/10
    (0xB1.U, "b1111111001".U, 10.U),           // 0/1
    (0xB2.U, "b1111111111010000".U, 16.U),           // 0/2
    (0xB3.U, "b1111111111010001".U, 16.U),           // 0/3
    (0xB4.U, "b1111111111010010".U, 16.U),           // 0/4
    (0xB5.U, "b1111111111010011".U, 16.U),           // 0/5
    (0xB6.U, "b1111111111010100".U, 16.U),           // 0/6
    (0xB7.U, "b1111111111010101".U, 16.U),           // 0/7
    (0xB8.U, "b1111111111010110".U, 16.U),           // 0/8
    (0xB9.U, "b1111111111010111".U, 16.U),           // 0/9
    (0xBA.U, "b1111111111011000".U, 16.U),           // 0/10
    (0xC1.U, "b1111111010".U, 10.U),           // 0/1
    (0xC2.U, "b1111111111011001".U, 16.U),           // 0/2
    (0xC3.U, "b1111111111011010".U, 16.U),           // 0/3
    (0xC4.U, "b1111111111011011".U, 16.U),           // 0/4
    (0xC5.U, "b1111111111011100".U, 16.U),           // 0/5
    (0xC6.U, "b1111111111011101".U, 16.U),           // 0/6
    (0xC7.U, "b1111111111011110".U, 16.U),           // 0/7
    (0xC8.U, "b1111111111011111".U, 16.U),           // 0/8
    (0xC9.U, "b1111111111100000".U, 16.U),           // 0/9
    (0xCA.U, "b1111111111100001".U, 16.U),           // 0/10
    (0xD1.U, "b11111111000".U, 11.U),           // 0/1
    (0xD2.U, "b1111111111100010".U, 16.U),           // 0/2
    (0xD3.U, "b1111111111100011".U, 16.U),           // 0/3
    (0xD4.U, "b1111111111100100".U, 16.U),           // 0/4
    (0xD5.U, "b1111111111100101".U, 16.U),           // 0/5
    (0xD6.U, "b1111111111100110".U, 16.U),           // 0/6
    (0xD7.U, "b1111111111100111".U, 16.U),           // 0/7
    (0xD8.U, "b1111111111101000".U, 16.U),           // 0/8
    (0xD9.U, "b1111111111101001".U, 16.U),           // 0/9
    (0xDA.U, "b1111111111101010".U, 16.U),           // 0/10
    (0xE1.U, "b1111111111101011".U, 16.U),           // 0/1
    (0xE2.U, "b1111111111101100".U, 16.U),           // 0/2
    (0xE3.U, "b1111111111101101".U, 16.U),           // 0/3
    (0xE4.U, "b1111111111101110".U, 16.U),           // 0/4
    (0xE5.U, "b1111111111101111".U, 16.U),           // 0/5
    (0xE6.U, "b1111111111110000".U, 16.U),           // 0/6
    (0xE7.U, "b1111111111110001".U, 16.U),           // 0/7
    (0xE8.U, "b1111111111110010".U, 16.U),           // 0/8
    (0xE9.U, "b1111111111110011".U, 16.U),           // 0/9
    (0xEA.U, "b1111111111110100".U, 16.U),           // 0/10
    (0xF1.U, "b1111111111110101".U, 16.U),           // 0/1
    (0xF2.U, "b1111111111110110".U, 16.U),           // 0/2
    (0xF3.U, "b1111111111110111".U, 16.U),           // 0/3
    (0xF4.U, "b1111111111111000".U, 16.U),           // 0/4
    (0xF5.U, "b1111111111111001".U, 16.U),           // 0/5
    (0xF6.U, "b1111111111111010".U, 16.U),           // 0/6
    (0xF7.U, "b1111111111111011".U, 16.U),           // 0/7
    (0xF8.U, "b1111111111111100".U, 16.U),           // 0/8
    (0xF9.U, "b1111111111111101".U, 16.U),           // 0/9
    (0xFA.U, "b1111111111111110".U, 16.U),           // 0/10
    
    (0xF0.U, "b11111111001".U, 11.U)  // ZRL (15/0)
  ).map { case (runSize, code, length) =>
      val entry = Wire(new HuffmanEntry)
      entry.runSize := runSize
      entry.code := code
      entry.length := length
      entry
    })
  }
}
object chrominanceAcTable {
  def apply(): Vec[HuffmanEntry] = {
    VecInit(Seq(
    (0x00.U, "b00".U, 2.U),           // EOB
    (0x01.U, "b01".U, 2.U),           // 0/1
    (0x02.U, "b100".U, 3.U),           // 0/2
    (0x03.U, "b1010".U, 4.U),           // 0/1
    (0x04.U, "b11000".U, 5.U),           // 0/2
    (0x05.U, "b11001".U, 5.U),           // 0/1
    (0x06.U, "b111000".U, 6.U),           // 0/2
    (0x07.U, "b1111000".U, 7.U),           // 0/1
    (0x08.U, "b111110100".U, 9.U),           // 0/2
    (0x09.U, "b1111110110".U, 10.U),           // 0/1
    (0x0A.U, "b111111110100".U, 12.U),           // 0/2
    (0x11.U, "b1011".U, 4.U),           // 0/1
    (0x12.U, "b111001".U, 6.U),           // 0/2
    (0x13.U, "b11110110".U, 8.U),           // 0/1
    (0x14.U, "b111110101".U, 9.U),           // 0/2
    (0x15.U, "b11111110110".U, 11.U),           // 0/1
    (0x16.U, "b111111110101".U, 12.U),           // 0/2
    (0x17.U, "b1111111110001000".U, 16.U),           // 0/1
    (0x18.U, "b1111111110001001".U, 16.U),           // 0/2
    (0x19.U, "b1111111110001010".U, 16.U),           // 0/1
    (0x1A.U, "b1111111110001011".U, 16.U),           // 0/2
    (0x21.U, "b11010".U, 5.U),           // 0/1
    (0x22.U, "b11110111".U, 8.U),           // 0/2
    (0x23.U, "b1111110111".U, 10.U),           // 0/1
    (0x24.U, "b111111110110".U, 12.U),           // 0/2
    (0x25.U, "b111111111000010".U, 15.U),           // 0/1
    (0x26.U, "b1111111110001100".U, 16.U),           // 0/2
    (0x27.U, "b1111111110001101".U, 16.U),           // 0/1
    (0x28.U, "b1111111110001110".U, 16.U),           // 0/2
    (0x29.U, "b1111111110001111".U, 16.U),           // 0/1
    (0x2A.U, "b1111111110010000".U, 16.U),           // 0/2
    (0x31.U, "b11011".U, 5.U),           // 0/1
    (0x32.U, "b11111000".U, 8.U),           // 0/2
    (0x33.U, "b1111111000".U, 10.U),           // 0/1
    (0x34.U, "b111111110111".U, 12.U),           // 0/2
    (0x35.U, "b1111111110010001".U, 16.U),           // 0/1
    (0x36.U, "b1111111110010010".U, 16.U),           // 0/2
    (0x37.U, "b1111111110010011".U, 16.U),           // 0/1
    (0x38.U, "b1111111110010100".U, 16.U),           // 0/2
    (0x39.U, "b1111111110010101".U, 16.U),           // 0/1
    (0x3A.U, "b1111111110010110".U, 16.U),           // 0/2
    (0x41.U, "b111010".U, 6.U),           // 0/1
    (0x42.U, "b111110110".U, 9.U),           // 0/2
    (0x43.U, "b1111111110010111".U, 16.U),           // 0/1
    (0x44.U, "b1111111110011000".U, 16.U),           // 0/2
    (0x45.U, "b1111111110011001".U, 16.U),           // 0/1
    (0x46.U, "b1111111110011010".U, 16.U),           // 0/2
    (0x47.U, "b1111111110011011".U, 16.U),           // 0/1
    (0x48.U, "b1111111110011100".U, 16.U),           // 0/2
    (0x49.U, "b1111111110011101".U, 16.U),           // 0/1
    (0x4A.U, "b1111111110011110".U, 16.U),           // 0/2
    (0x51.U, "b111011".U, 6.U),           // 0/1
    (0x52.U, "b1111111001".U, 10.U),           // 0/2
    (0x53.U, "b1111111110011111".U, 16.U),           // 0/1
    (0x54.U, "b1111111110100000".U, 16.U),           // 0/2
    (0x55.U, "b1111111110100001".U, 16.U),           // 0/1
    (0x56.U, "b1111111110100010".U, 16.U),           // 0/2
    (0x57.U, "b1111111110100011".U, 16.U),           // 0/1
    (0x58.U, "b1111111110100100".U, 16.U),           // 0/2
    (0x59.U, "b1111111110100101".U, 16.U),           // 0/1
    (0x5A.U, "b1111111110100110".U, 16.U),           // 0/2
    (0x61.U, "b1111001".U, 7.U),           // 0/1
    (0x62.U, "b11111110111".U, 11.U),           // 0/2
    (0x63.U, "b1111111110100111".U, 16.U),           // 0/1
    (0x64.U, "b1111111110101000".U, 16.U),           // 0/2
    (0x65.U, "b1111111110101001".U, 16.U),           // 0/1
    (0x66.U, "b1111111110101010".U, 16.U),           // 0/2
    (0x67.U, "b1111111110101011".U, 16.U),           // 0/1
    (0x68.U, "b1111111110101100".U, 16.U),           // 0/2
    (0x69.U, "b1111111110101101".U, 16.U),           // 0/1
    (0x6A.U, "b1111111110101110".U, 16.U),           // 0/2
    (0x71.U, "b1111010".U, 7.U),           // 0/1
    (0x72.U, "b111111110000".U, 12.U),           // 0/2
    (0x73.U, "b1111111110101111".U, 16.U),           // 0/1
    (0x74.U, "b1111111110110000".U, 16.U),           // 0/2
    (0x75.U, "b1111111110110001".U, 16.U),           // 0/1
    (0x76.U, "b1111111110110010".U, 16.U),           // 0/2
    (0x77.U, "b1111111110110011".U, 16.U),           // 0/1
    (0x78.U, "b1111111110110100".U, 16.U),           // 0/2
    (0x79.U, "b1111111110110101".U, 16.U),           // 0/1
    (0x7A.U, "b1111111110110110".U, 16.U),           // 0/2
    (0x81.U, "b11111001".U, 8.U),           // 0/1
    (0x82.U, "b1111111110110111".U, 16.U),           // 0/2
    (0x83.U, "b1111111110111000".U, 16.U),           // 0/1
    (0x84.U, "b1111111110111001".U, 16.U),           // 0/2
    (0x85.U, "b1111111110111010".U, 16.U),           // 0/1
    (0x86.U, "b1111111110111011".U, 16.U),           // 0/2
    (0x87.U, "b1111111110111100".U, 16.U),           // 0/1
    (0x88.U, "b1111111110111101".U, 16.U),           // 0/2
    (0x89.U, "b1111111110111110".U, 16.U),           // 0/1
    (0x8A.U, "b1111111110111111".U, 16.U),           // 0/2
    (0x91.U, "b111110111".U, 9.U),           // 0/1
    (0x92.U, "b1111111111000000".U, 16.U),           // 0/2
    (0x93.U, "b1111111111000001".U, 16.U),           // 0/1
    (0x94.U, "b1111111111000010".U, 16.U),           // 0/2
    (0x95.U, "b1111111111000011".U, 16.U),           // 0/1
    (0x96.U, "b1111111111000100".U, 16.U),           // 0/2
    (0x97.U, "b1111111111000101".U, 16.U),           // 0/1
    (0x98.U, "b1111111111000110".U, 16.U),           // 0/2
    (0x99.U, "b1111111111000111".U, 16.U),           // 0/1
    (0x9A.U, "b1111111111001000".U, 16.U),           // 0/2
    (0xA1.U, "b111111000".U, 9.U),           // 0/1
    (0xA2.U, "b1111111111001001".U, 16.U),           // 0/2
    (0xA3.U, "b1111111111001010".U, 16.U),           // 0/1
    (0xA4.U, "b1111111111001011".U, 16.U),           // 0/2
    (0xA5.U, "b1111111111001100".U, 16.U),           // 0/1
    (0xA6.U, "b1111111111001101".U, 16.U),           // 0/2
    (0xA7.U, "b1111111111001110".U, 16.U),           // 0/1
    (0xA8.U, "b1111111111001111".U, 16.U),           // 0/2
    (0xA9.U, "b1111111111010000".U, 16.U),           // 0/1
    (0xAA.U, "b1111111111010001".U, 16.U),           // 0/2
    (0xB1.U, "b111111001".U, 9.U),           // 0/1
    (0xB2.U, "b1111111111010010".U, 16.U),           // 0/2
    (0xB3.U, "b1111111111010011".U, 16.U),           // 0/1
    (0xB4.U, "b1111111111010100".U, 16.U),           // 0/2
    (0xB5.U, "b1111111111010101".U, 16.U),           // 0/1
    (0xB6.U, "b1111111111010110".U, 16.U),           // 0/2
    (0xB7.U, "b1111111111010111".U, 16.U),           // 0/1
    (0xB8.U, "b1111111111011000".U, 16.U),           // 0/2
    (0xB9.U, "b1111111111011001".U, 16.U),           // 0/1
    (0xBA.U, "b1111111111011010".U, 16.U),           // 0/2
    (0xC1.U, "b111111010".U, 9.U),           // 0/1
    (0xC2.U, "b1111111111011011".U, 16.U),           // 0/2
    (0xC3.U, "b1111111111011100".U, 16.U),           // 0/1
    (0xC4.U, "b1111111111011101".U, 16.U),           // 0/2
    (0xC5.U, "b1111111111011110".U, 16.U),           // 0/1
    (0xC6.U, "b1111111111011111".U, 16.U),           // 0/2
    (0xC7.U, "b1111111111100000".U, 16.U),           // 0/1
    (0xC8.U, "b1111111111100001".U, 16.U),           // 0/2
    (0xC9.U, "b1111111111100010".U, 16.U),           // 0/1
    (0xCA.U, "b1111111111100011".U, 16.U),           // 0/2    
    (0xD1.U, "b11111111001".U, 11.U),           // 0/1
    (0xD2.U, "b1111111111100100".U, 16.U),           // 0/2
    (0xD3.U, "b1111111111100101".U, 16.U),           // 0/1
    (0xD4.U, "b1111111111100110".U, 16.U),           // 0/2
    (0xD5.U, "b1111111111100111".U, 16.U),           // 0/1
    (0xD6.U, "b1111111111101000".U, 16.U),           // 0/2
    (0xD7.U, "b1111111111101001".U, 16.U),           // 0/1
    (0xD8.U, "b1111111111101010".U, 16.U),           // 0/2
    (0xD9.U, "b1111111111101011".U, 16.U),           // 0/1
    (0xDA.U, "b1111111111101100".U, 16.U),           // 0/2
    (0xE1.U, "b11111111100000".U, 14.U),           // 0/1
    (0xE2.U, "b1111111111101101".U, 16.U),           // 0/2
    (0xE3.U, "b1111111111101110".U, 16.U),           // 0/1
    (0xE4.U, "b1111111111101111".U, 16.U),           // 0/2
    (0xE5.U, "b1111111111110000".U, 16.U),           // 0/1
    (0xE6.U, "b1111111111110001".U, 16.U),           // 0/2
    (0xE7.U, "b1111111111110010".U, 16.U),           // 0/1
    (0xE8.U, "b1111111111110011".U, 16.U),           // 0/2
    (0xE9.U, "b1111111111110100".U, 16.U),           // 0/1
    (0xEA.U, "b1111111111110101".U, 16.U),           // 0/2
    (0xF1.U, "b111111111000011".U, 15.U),           // 0/1
    (0xF2.U, "b1111111111110110".U, 16.U),           // 0/2
    (0xF3.U, "b1111111111110111".U, 16.U),           // 0/1
    (0xF4.U, "b1111111111111000".U, 16.U),           // 0/2
    (0xF5.U, "b1111111111111001".U, 16.U),           // 0/1
    (0xF6.U, "b1111111111111010".U, 16.U),           // 0/2
    (0xF7.U, "b1111111111111011".U, 16.U),           // 0/1
    (0xF8.U, "b1111111111111100".U, 16.U),           // 0/2
    (0xF9.U, "b1111111111111101".U, 16.U),           // 0/1
    (0xFA.U, "b1111111111111110".U, 16.U),           // 0/2
    
    (0xF0.U, "b1111111010".U, 10.U)   // ZRL (15/0)
  ).map { case (runSize, code, length) =>
      val entry = Wire(new HuffmanEntry)
      entry.runSize := runSize
      entry.code := code
      entry.length := length
      entry
    })
  }
}
class HuffmanAcEncoder extends Module {
  val io = IO(new Bundle {
    val run = Input(UInt(4.W))        // AC Run 值
    val size = Input(UInt(4.W))       // AC Size 值
    val amplitude = Input(SInt(12.W)) // 幅值
    val isLuminance = Input(Bool())   // 是否為 Luminance
    val out = Output(new Bundle {
      val bits = UInt(16.W) // 最終編碼位元流
      val length = UInt(8.W) // 編碼總長度
    })
  })
  
  val runSize = Cat(io.run, io.size)
  // val luminanceTable = VecInit(luminanceAcTable)
  // val chrominanceTable = VecInit(chrominanceAcTable)
  io.out.bits := 0.U
  io.out.length := 0.U
  when(io.isLuminance) {
    // 使用亮度表格
    for (entry <- luminanceAcTable()) {
      when(entry.runSize === runSize) {
        io.out.bits := entry.code
        io.out.length := entry.length
      }
    }
  }.otherwise {
    // 使用色度表格
    for (entry <- chrominanceAcTable()) {
      when(entry.runSize === runSize) {
        io.out.bits := entry.code
        io.out.length := entry.length
      }
    }
  }
}

class HuffmanDcDecoder extends Module{
  val io = IO(new Bundle {
    val in = new Bundle {
      val bits = Input(UInt(16.W))      // 輸入的編碼位元
      val length = Input(UInt(8.W))     // 編碼長度
      val isLuminance = Input(Bool())   // 是否為亮度資料
    }
    val out = new Bundle {
      val value = Output(SInt(12.W))     // 解碼後的 DC 值
    }
  })
  val luminanceDcTable = VecInit(Seq(
    "b00".U(16.W),         // 0: 00
    "b010".U(16.W),        // 1: 010
    "b011".U(16.W),        // 2: 011
    "b100".U(16.W),        // 3: 100
    "b101".U(16.W),        // 4: 101
    "b110".U(16.W),        // 5: 110
    "b1110".U(16.W),       // 6: 1110
    "b11110".U(16.W),      // 7: 11110
    "b111110".U(16.W),     // 8: 111110
    "b1111110".U(16.W),    // 9: 1111110
    "b11111110".U(16.W),   // 10: 11111110
    "b111111110".U(16.W)   // 11: 111111110
  ))

  // DC 色度的 Huffman 表
  val chrominanceDcTable = VecInit(Seq(
    "b00".U(16.W),         // 0: 00
    "b01".U(16.W),         // 1: 01
    "b10".U(16.W),         // 2: 10
    "b110".U(16.W),        // 3: 110
    "b1110".U(16.W),       // 4: 1110
    "b11110".U(16.W),      // 5: 11110
    "b111110".U(16.W),     // 6: 111110
    "b1111110".U(16.W),    // 7: 1111110
    "b11111110".U(16.W),   // 8: 11111110
    "b111111110".U(16.W),  // 9: 111111110
    "b1111111110".U(16.W), // 10: 1111111110
    "b11111111110".U(16.W) // 11: 11111111110
  ))
  val selectedTable = Mux(io.in.isLuminance, luminanceDcTable, chrominanceDcTable)

  // 找出 category (size)
  val category = Wire(UInt(4.W))
  category := 0.U
  for (i <- 0 until 12) {
    when(io.in.bits === selectedTable(i)) {
      category := i.U
    }
  }

  // 解碼真實值
  // 根據 category 從 amplitude 中讀取正確的位數
  val amplitude = Wire(SInt(12.W))
  when(category === 0.U) {
    amplitude := 0.S
  }.otherwise {
    // 從輸入位元中取出額外的位元表示實際值
    val mask = (1.U << category) - 1.U
    val absValue = io.in.bits & mask
    // 如果最高位是 1，則是正數；否則是負數
    when(io.in.bits(category.asUInt - 1.U)) {
      amplitude := absValue.asSInt
    }.otherwise {
      amplitude := ((-absValue).asSInt - 1.S)
    }
  }

  io.out.value := amplitude
}

class HuffmanAcDecoder extends Module{
  val io = IO(new Bundle {
    val in = new Bundle {
      val bits = Input(UInt(16.W))      // 輸入的編碼位元
      val length = Input(UInt(8.W))     // 編碼長度
      val isLuminance = Input(Bool())   // 是否為亮度資料
    }
    val out = new Bundle {
      val run = Output(UInt(4.W))        // 解碼後的 run 值
      val size = Output(UInt(4.W))       // 解碼後的 size 值
      val amplitude = Output(SInt(12.W))  // 解碼後的幅值
    }
  })

  // 選擇使用哪個表格（從 object 中獲取）
  val luminanceTable = luminanceAcTable()
  val chrominanceTable = chrominanceAcTable()
  val selectedTable = Mux(io.in.isLuminance, luminanceTable, chrominanceTable)

  // 找到匹配的表項
  val matchEntry = Wire(new HuffmanEntry)
  matchEntry := selectedTable(0) // 默認值
  
  for (i <- 0 until selectedTable.length) {
    when(io.in.bits === selectedTable(i).code && 
         io.in.length === selectedTable(i).length) {
      matchEntry := selectedTable(i)
    }
  }

  // 從 runSize 中提取 run 和 size
  io.out.run := matchEntry.runSize(7, 4)  // 高4位是 run
  io.out.size := matchEntry.runSize(3, 0)  // 低4位是 size

  // 解碼振幅值
  val size = io.out.size
  when(size === 0.U) {
    io.out.amplitude := 0.S
  }.otherwise {
    // 從輸入位元中取出額外的位元表示實際值
    val mask = (1.U << size) - 1.U
    val absValue = io.in.bits & mask
    // 如果最高位是 1，則是正數；否則是負數
    when(io.in.bits(size.asUInt - 1.U)) {
      io.out.amplitude := absValue.asSInt
    }.otherwise {
      io.out.amplitude := ((-absValue).asSInt - 1.S)
    }
  }
}